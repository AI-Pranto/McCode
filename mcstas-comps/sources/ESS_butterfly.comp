/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2016, All rights reserved
*         DTU Physics, Kongens Lyngby, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: ESS_butterfly
*
* %I
*
* Written by: Peter Willendrup and Esben Klinkby
* Date: April-May 2016
* Version: $Revision$
* Release: McStas 2.3
* Origin: DTU
*
* ESS butterfly moderator, 2016 revision
*
* %D
* ESS butterfly moderator with automatic choice of coordinate system, with origin
* placed at relevant "Moderator Focus Coordinate System" depending on sector location.
*
* Implements current "engineering reality" for geometry and brilliances of the cold 
* and thermal moderators.
*
* %P
* Input parameters:
* sector:       [str] Defines the 'sector' of your instrument position. Valid values are "N","S","E" and "W"
* beamline:     [1]   Defines the 'beamline number' of your instrument position. Valid values are 1..10 or 1..11 depending on sector
* yheight:      [m]   Defines the moderator height. Valid values are 0.03 m and 0.06 m
* cold_frac:    [1]   Defines the statistical fraction of events emitted from the cold part of the moderator
* performance:  [1]   Scalar performance multiplicator 0 < performace <= 1
* Lmin:         [AA]  Minimum wavelength simulated
* Lmax:         [AA]  Maximum wavelength simulated
* target_index: [1]   Relative index of component to focus at, e.g. next is +1 this is used to compute 'dist' automatically.
* dist:         [m]   Distance from origin to focusing rectangle; at (0,0,dist) - alternatively use target_index\
* focus_xw      [m]   Width of focusing rectangle
* focus_yh	[m]   Height of focusing rectangle
*
* %E
*******************************************************************************/

DEFINE COMPONENT ESS_butterfly
DEFINITION PARAMETERS ()
SETTING PARAMETERS (string sector="N",int beamline=1, yheight=0.03, cold_frac=0.5, int target_index=0, dist=0, focus_xw=0, focus_yh=0, 
		      performance=1, Lmin, Lmax)
OUTPUT PARAMETERS (cx, cz, sign_bl_angle, orientation_angle)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */ 
DECLARE
%{
  /* Centering-parameters, which sector are we in? */
  double cx, cz;
  int sign_bl_angle;
  double orientation_angle;
  /* 10 beamlines in sector N and E  - plus one location added for drawing */
  double BeamlinesN[] = { 30.0,  36.0,  42.0,  48.0,  54.0,  60.0,  66.0,  72.0,  78.0,  84.0,  90.0};
  double BeamlinesE[] = {-30.0, -36.0, -42.0, -48.0, -54.0, -60.0, -66.0, -72.0, -78.0, -84.0, -90.0};
  /* 11 beamlines in sector S and W - plus one location added for drawing */
  double BeamlinesW[] = { 150.0,  144.7,  138.0,  132.7,  126.0,  120.7,  114.0,  108.7,  102.0,  96.7,  90.0,  84.0};
  double BeamlinesS[] = {-150.0, -144.7, -138.0, -132.7, -126.0, -120.7, -114.0, -108.7, -102.0, -96.7, -90.0, -84.0};
  double* Beamlines;
  int jmax;
  /* 'Corner' parametrization, i.e. where are the limits of the moderators */
  double C1_x,C1_z,C2_x,C2_z;
  double T1_x,T1_z,T2_x,T2_z;
  /* - plus rotated versions of the same... */
  double rC1_x,rC1_z,rC2_x,rC2_z;
  double rT1_x,rT1_z,rT2_x,rT2_z;
  double tx,ty,tz;
  double r11, r12, r21, r22;
  int iscold;
  double xtmp;
  double dy;
  double xf, yf, zf;
  double w_geom, w_focus;
  double tx,ty,tz;
%}

INITIALIZE
%{
  /* Centering-parameters, which sector are we in? */
  if (strcasestr(sector,"N")) {
    cx = 0.117; cz=0.0; sign_bl_angle=1;
    orientation_angle = BeamlinesN[beamline-1];
    Beamlines = BeamlinesN;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-0.18;
    T2_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-0.10*cos(-156*DEG2RAD);
    C2_z=0.10*sin(-156*DEG2RAD);
  } else if (strcasestr(sector,"W")) {
    cx = 0.0; cz=0.0; sign_bl_angle=-1;
    orientation_angle = BeamlinesW[beamline-1]; 
    Beamlines = BeamlinesW;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=0.18;
    T2_z=0;
    T1_x=0;
    C1_z=0;
    C2_x=0.10*cos(-156*DEG2RAD);
    C2_z=0.10*sin(-156*DEG2RAD);
  } else if (strcasestr(sector,"S")) {
    cx = 0.0; cz=-0.185; sign_bl_angle=1;
    orientation_angle = BeamlinesS[beamline-1]; 
    Beamlines = BeamlinesS;
    jmax=11;
    T1_x=0;
    T1_z=0;
    T2_x=0.18;
    T2_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=0.10*cos(156*DEG2RAD);
    C2_z=0.10*sin(156*DEG2RAD);
  } else if (strcasestr(sector,"E")) {
    cx = 0.117; cz=-0.185; sign_bl_angle=-1;
    orientation_angle = BeamlinesE[beamline-1]; 
    Beamlines = BeamlinesE;
    jmax=10;
    T1_x=0;
    T1_z=0;
    T2_x=-0.18;
    T2_z=0;
    C1_x=0;
    C1_z=0;
    C2_x=-0.10*cos(-156*DEG2RAD);
    C2_z=-0.10*sin(-156*DEG2RAD);
  } else {
    fprintf(stderr,"%s: Sector %s is undefined, please use N, W, S or E!\n", NAME_CURRENT_COMP,sector);
    exit(-1);
  }
  if (beamline > jmax || beamline <= 0 ) {
    fprintf(stderr,"%s: beamline no %i is undefined in sector %s, please use 1 <= beamline <= %i\n", NAME_CURRENT_COMP, beamline, sector, jmax);
    exit(-1);
  }
  printf("Setting up for sector %s, beamline %i, global orientation angle is %g\n",sector,beamline,orientation_angle);
  if (performance <= 0 || performance > 1) {
    fprintf(stderr,"%s: performance scalar of %g is not allowed. Please select 0 < performance <= 1\n", NAME_CURRENT_COMP, performance);
    exit(-1);
  }
  if (Lmin>=Lmax || Lmin <= 0 || Lmax < 0) {
    printf("%s: Unmeaningful definition of wavelength range!\nPlease select Lmin, Lmax > 0 and Lmax > Lmin.\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(-1);
  }
  /* Figure out where to aim */
  if (target_index && !dist)
  {
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &tx, &ty, &tz);
    dist=sqrt(tx*tx+ty*ty+tz*tz);
  } else if (!target_index && !dist) {
    printf("ESS_butterfly: %s: Please choose to set either the dist parameter or specify a target_index.\nExit\n", NAME_CURRENT_COMP);
    exit(-1);
  } else {
    tx=0; ty=0; tz=dist;
  }
  printf("Focusing at rectagle sized %g x %g \n positioned at location %g %g %g (target_index %i and dist %g)\n", focus_xw, focus_yh, tx, ty, tz, target_index, dist);
  /* Issue warning if dist < 2m - TODO */
  
  /* Calculate orientation matrix for the display and calculations */
  r11 = cos(DEG2RAD*orientation_angle);
  r12 = -sin(DEG2RAD*orientation_angle);
  r21 = sin(DEG2RAD*orientation_angle);
  r22 = cos(DEG2RAD*orientation_angle);
  
  /* Rotated corrdinates of the emission areas */
  rC1_x = r11*C1_z + r12*C1_x;
  rC1_z = r21*C1_z + r22*C1_x;
  rC2_x = r11*C2_z + r12*C2_x;
  rC2_z = r21*C2_z + r22*C2_x;
  rT1_x = r11*T1_z + r12*T1_x;
  rT1_z = r21*T1_z + r22*T1_x;
  rT2_x = r11*T2_z + r12*T2_x;
  rT2_z = r21*T2_z + r22*T2_x;
  /* Moderator half-height */
  dy = yheight/2.0;
%}

TRACE
%{
  
  /* Cold or thermal event? */
  xtmp = rand01();
  if (rand01() < cold_frac) {
    iscold=1;
    y = randpm1()*dy;
    x = rC1_x + (rC2_x - rC1_x)*xtmp;
    z = rC1_z + (rC2_z - rC1_z)*xtmp;
  } else {
    iscold=0;
    y = randpm1()*dy;
    x = rT1_x + (rT2_x - rT1_x)*xtmp;
    z = rT1_z + (rT2_z - rT1_z)*xtmp;
  }
  SCATTER;
  /* Where are we going? */
  randvec_target_rect_real(&xf, &yf, &zf, NULL,
			   tx, ty, tz, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 0);
  w_focus=focus_xw*focus_yh/(tx*tx+ty*ty+tz*tz);
  x=xf;y=yf;z=zf;
  SCATTER;
  
%}

MCDISPLAY
%{
%include "ESS_butterfly-geometry.c"
%}

END
