/*******************************************************************************
*
* McXtrace, xray-tracing package
*         Copyright 1997-2016, All rights reserved
*         DTU Physics, Kgs. Lyngby, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Divergence_monitor
*
* %I
* Written by: Erik B Knudsen
* Based on neutron component by Kim Lefmann
* Date: Jun. '16
* Version: $Revision$
* Origin: DTU Physics
* Release: McXtrace 1.3
*
* Multipurpose monitor.
*
* %D
* A combined PSD, energy, and divergence sensitive monitor.
* For the position sensitive (PSD) part the monitr is a nX by nX monitor with
* a number of different resolutions ranging from 25\mu m to 2.5mm pixel sides.
* 
*
* Example: Divergence_monitor(nh=20, nv=20, filename="Output.pos",
*           xmin=-0.1, xmax=0.1, ymin=-0.1, ymax=0.1,
*           maxdiv_h=2, maxdiv_v=2)
*
* %P
* INPUT PARAMETERS:
*
* xwidth:  [m]  Default width of the divergence and energy monitor.
* yheight: [m]  Default height of the divergence and energy monitor.
* xwidth_div:  [m]  Width of divergence monitor.
* yheight_div: [m]  Height of divergence monitor.
* xwidth_emon:  [m]  Width of energy monitor.
* yheight_emon: [m]  Height of energy_monitor.
* ndiv:    [1]  Number of pixels along one dimension for divergence
* sx:      [1]
* sy:      [1]  Vector definition of "forward" direction wrt. divergence, to be used e.g. when the monitor is rotated into the horizontal plane.
* sz:      [1]
* maxdiv_v: [deg/rad] Maximal vertical divergence detected (degrees/rad)
* maxdiv_h: [deg/rad] Maximal horizontal divergence detected (degrees/rad)
* rad:     [1] If set - divergence will be measured in radians. (1)
* nX:      [1]  Number of pixels along on dimension of the PSD elements.
* nEfull:  [1]  Number of energy bins for the wide range E-monitor block. 
* nE:      [1]  Number of energy bins for the focused E-monitor. 
* E0:      [keV] Central energy for the focused E-monitor.
* dE:      [keV] Half-width of the fpocused energy monitor.
* filename:[ ] Stem of filenames in which to store the detector data. Suffixes div-%d,emon-%d, abd psd-%d will be added as appropriate.
* restore_xray: [1]  If set, the monitor does not influence the xray state (1)
*
* OUTPUT PARAMETERS:
*
* monitor_data:    a struct carrying all the monitor data
* psd_res:         the pixel sides of the different PSDs.
* div_res:         Bin sizes of the divergence monitors.
*
* %E
*******************************************************************************/
DEFINE COMPONENT DanMAX_monitor
DEFINITION PARAMETERS (ndiv=20, nX=201, nEfull=4001, nE=200, rad=1)
SETTING PARAMETERS (string filename=0, xwidth=0.1, yheight=0.1,xwidth_div=0, yheight_div=0, xwidth_emon=0,yheight_emon=0, E0=15, dE=2,
        Efull_min=10, Efull_max=50, restore_xray=0, sx=0, sy=0, sz=1)
OUTPUT PARAMETERS (monitor_data, psd_res, div_res)
/* Xray  parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

SHARE
%{
    enum psd_variants {pULTRAFINE, pVERYFINE, pFINE, pMEDIUM, pCOARSE, pVERYCOARSE, pTOTAL};
    enum div_variants {dFINE, dMEDIUM, dCOARSE, dTOTAL};
%}

DECLARE
  %{
    double psd_res[pTOTAL]={25e-6, 100e-6, 250e-6, 500e-6, 1000e-6, 2500e-6};
    double div_res[dTOTAL]={0.1e-5, 1e-5, 10e-5};

    struct {
        double Div_N[dTOTAL][ndiv][ndiv], PSD_N[pTOTAL][nX][nX], Efull_N[nEfull], E_N[nE];
        double Div_p[dTOTAL][ndiv][ndiv], PSD_p[pTOTAL][nX][nX], Efull_p[nEfull], E_p[nE];
        double Div_p2[dTOTAL][ndiv][ndiv], PSD_p2[pTOTAL][nX][nX], Efull_p2[nEfull], E_p2[nE];
    } monitor_data;
%}

INITIALIZE
  %{
    int i,j,k;

    if (xwidth  > 0) {
        if(!xwidth_div) xwidth_div=xwidth;
        if(!xwidth_emon) xwidth_emon=xwidth;
    }
    if (yheight  > 0) {
        if(!yheight_div) yheight_div=yheight;
        if(!yheight_emon) yheight_emon=yheight;
    }

 
    for (i=0; i<dTOTAL; i++)
        for (j=0; j<ndiv; j++)
            for (k=0; k<ndiv; k++){
                monitor_data.Div_N[i][j][k] = 0;
                monitor_data.Div_p[i][j][k] = 0;
                monitor_data.Div_p2[i][j][k] = 0;
            }
    for (i=0; i<pTOTAL; i++)
        for (j=0; j<nX; j++)
            for (k=0; k<nX; k++){
                monitor_data.PSD_N[i][j][k] = 0;
                monitor_data.PSD_p[i][j][k] = 0;
                monitor_data.PSD_p2[i][j][k] = 0;
            }
    for (i=0; i<nEfull; i++){
        monitor_data.Efull_N[i]=0;
        monitor_data.Efull_p[i]=0;
        monitor_data.Efull_p2[i]=0;
    }
    for (i=0; i<nE; i++){
        monitor_data.E_N[i]=0;
        monitor_data.E_p[i]=0;
        monitor_data.E_p2[i]=0;
    }

    NORM(sx,sy,sz);
  %}
TRACE
  %{
    int i,j,k;
    double h_div, v_div;
    double kn;

    PROP_Z0;
    
    if (x>-xwidth/2.0 && x<xwidth/2.0 && y>-yheight/2.0 && y<yheight/2.0){
        /*do we hit the divergence monitor at all?*/
        /*first loop over the divergence monitors, lowering the dimensions of the monitor as we go along.*/
        for (i=dTOTAL-1;i>=0; i--){
            double maxdiv_h=div_res[i]/2.0;
            double maxdiv_v=div_res[i]/2.0;

            /* Find length of projection onto the [nx ny nz] axis */
            kn = scalar_prod(kx, ky, kz, sx, sy, sz);
            if (rad){
                h_div = atan2(kx,kn);
                v_div = atan2(ky,kn);
            }else{
                h_div = RAD2DEG*atan2(kx,kn);
                v_div = RAD2DEG*atan2(ky,kn);
            }
            if (h_div < maxdiv_h && h_div > -maxdiv_h &&
                    v_div < maxdiv_v && v_div > -maxdiv_v)
            {
                j = floor((h_div + maxdiv_h)*ndiv/(2.0*maxdiv_h));
                k = floor((v_div + maxdiv_v)*ndiv/(2.0*maxdiv_v));
                monitor_data.Div_N[i][j][k]++;
                monitor_data.Div_p[i][j][k] += p;
                monitor_data.Div_p2[i][j][k] += p*p;
                SCATTER;
            }else{
                break;
            }
        }
    }   

    /*now do the psds*/
    for (i=pTOTAL-1;i>=0;i--){
        double xwidth_psd=psd_res[i];
        double yheight_psd=psd_res[i];
        double xmin=-xwidth_psd/2.0;
        double ymin=-yheight_psd/2.0;
        if (x>-xwidth_psd/2.0 && x<xwidth_psd/2.0 && y>-yheight_psd/2.0 && y<yheight_psd/2.0){
            j = floor((x - xmin)*nX/(xwidth_psd));
            k = floor((y - ymin)*nX/(yheight_psd));
            monitor_data.PSD_N[i][j][k]++;
            monitor_data.PSD_p[i][j][k] += p;
            monitor_data.PSD_p2[i][j][k] += p*p;
            SCATTER;
        }else{
            break;
        }
    }

    /*the emons*/
    if (x>-xwidth_emon/2.0 && x<xwidth_emon/2.0 && y>-yheight_emon/2.0 && y<yheight_emon/2.0){
      double E = K2E*sqrt(kx*kx + ky*ky + kz*kz);
      i = floor((E-Efull_min)*nEfull/(Efull_max-Efull_min));
      if(i >= 0 && i < nEfull){
          monitor_data.Efull_N[i]++;
          monitor_data.Efull_p[i] += p;
          monitor_data.Efull_p2[i] += p*p;
          SCATTER;
      }
      i = floor((E-(E0-dE))*nE/(2*dE));
      if(i >= 0 && i < nE){
          monitor_data.E_N[i]++;
          monitor_data.E_p[i] += p;
          monitor_data.E_p2[i] += p*p;
          SCATTER;
      }
    }

    if (restore_xray) {
        RESTORE_XRAY(INDEX_CURRENT_COMP, x, y, z, kx, ky, kz, phi, t, Ex, Ey, Ez, p);
    }
%}

SAVE
%{
    int i;

    char fn[CHAR_BUF_LENGTH];
    /*save divergence monitors*/
    for (i=dTOTAL-1;i>=0; i--){
        snprintf(fn,CHAR_BUF_LENGTH-1,"%s.div-%d",filename,i);
        double maxdiv_h=div_res[i]/2.0;
        double maxdiv_v=div_res[i]/2.0;

        if (rad){
          DETECTOR_OUT_2D(
                  "Divergence monitor",
                  "X divergence [rad]",
                  "Y divergence [rad]",
                  -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
                  ndiv, ndiv,
                  &(monitor_data.Div_N[i][0][0]),&(monitor_data.Div_p[i][0][0]),&(monitor_data.Div_p2[i][0][0]),
                  fn);
        } else {
            DETECTOR_OUT_2D(
                    "Divergence monitor",
                    "X divergence [deg]",
                    "Y divergence [deg]",
                    -maxdiv_h, maxdiv_h, -maxdiv_v, maxdiv_v,
                    ndiv, ndiv,
                    &(monitor_data.Div_N[i][0][0]),&(monitor_data.Div_p[i][0][0]),&(monitor_data.Div_p2[i][0][0]),
                    fn);
        }
    }

    /*PSDs*/
    for (i=pTOTAL-1;i>=0; i--){
        snprintf(fn,CHAR_BUF_LENGTH-1,"%s.psd-%d",filename,i);
        double xwidth_psd=psd_res[i];
        double yheight_psd=psd_res[i];
        printf("psdsize: %d %d %g %g\n", pTOTAL, i, xwidth_psd, yheight_psd); 
        DETECTOR_OUT_2D(
                "PSD monitor",
                "X position [m]",
                "Y position [m]",
                -xwidth_psd/2.0, xwidth_psd/2.0, -yheight_psd/2.0, yheight_psd/2.0,
                nX, nX,
                &(monitor_data.PSD_N[i][0][0]),&(monitor_data.PSD_p[i][0][0]),&(monitor_data.PSD_p2[i][0][0]),
                fn);
    }

    /*save E_monitors*/
    snprintf(fn,CHAR_BUF_LENGTH-1,"%s.emon_full",filename);
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [keV]",
        "Intensity",
        "E", Efull_min, Efull_max, nEfull,
        &(monitor_data.Efull_N[0]),&(monitor_data.Efull_p[0]),&(monitor_data.Efull_p2[0]),
        fn);

    snprintf(fn,CHAR_BUF_LENGTH-1,"%s.emon",filename);
    DETECTOR_OUT_1D(
        "Energy monitor",
        "Energy [keV]",
        "Intensity",
        "E", E0-dE, E0+dE, nE,
        &(monitor_data.E_N[0]),&(monitor_data.E_p[0]),&(monitor_data.E_p2[0]),
        fn);

%}

MCDISPLAY
%{
      int i;
    magnify("xy");
    rectangle("xy",0,0,0,xwidth_div,yheight_div);

    for (i=pTOTAL-1;i--; i<=0){
        double xwidth_psd=psd_res[i]*nX;
        double yheight_psd=psd_res[i]*nX;
        rectangle("xy",0,0,0,xwidth_psd,yheight_psd);
    }

    rectangle("xy",0,0,0,xwidth_emon,yheight_emon);

%}

END

