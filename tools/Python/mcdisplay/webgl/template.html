<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<style>
		body { margin: 0; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script>
		// add multiline
		// 		arrVector3 - an array of THREE.Vector3 instances
		var addMultiLineV3 = function(arrVector3)
		{
			var multilinematerial = new THREE.LineBasicMaterial({color: 0x0000ff});
			var multilinegeometry = new THREE.Geometry();
			for (var i = 0; i < arrVector3.length; i++)
			{
				multilinegeometry.vertices.push(arrVector3[i]);
			}
			var multiline = new THREE.Line(multilinegeometry, multilinematerial);
			lastComp.add(multiline);
		}
		// add multiline proxy method
		//		points - array of single points
		var addMultiLine = function(points)
		{
			vectors = [];
			for (var i = 0; i < points.length / 3; i++)
			{
				points[i];
				v = new THREE.Vector3(points[i*3], points[i*3+1], points[i*3+2]);
				vectors.push(v);
			}
			addMultiLineV3(vectors);
		}
		// add a component origo
		//		pos - position of component ore
		var addComponent = function()
		{
			var comp = new THREE.Object3D();
			lastComp.children.push(comp);
			lastComp = comp;
		}
		// finalize by adding and applying position and rotation for this comp and its vertices
		//
		var finalizeComponent = function(position, rotation)
		{
			var m = new THREE.Matrix4();
			m.setPosition(position);
			m.setRotation(rotation)
			lastComp.applyMatrix(m);
		}
		// add circle to xy plane
		// 		radius
		// 		center - a THREE.Vector3 instance
		var addCircle = function(radius, center)
		{
			var material = new THREE.MeshBasicMaterial({
				color: 0x0000ff
			});
			var segments = 32;
			var circleGeometry = new THREE.CircleGeometry( radius, segments );
			var circle = new THREE.Mesh( circleGeometry, material );
			circle.position.x = center.x;
			circle.position.y = center.y;
			circle.position.z = center.z;
			scene.add( circle );
		}
		// add sphere
		//		radius
		//		wseg 	- width segments
		//		hseg 	- height segments
		var addSphere = function(radius, wseg, hseg)
		{
			var geometry = new THREE.SphereGeometry(radius, wseg, hseg);
			var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
			var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
			var sphere = new THREE.Mesh( geometry, sphereMaterial );
			scene.add( sphere );
		}
		// add pointlight
		// 		center 	- THREE.Vector3 instance
		var addLight = function(center, scene)
		{
	        // pointlight (required to light up sphereMaterial)
	        var pointLight = new THREE.PointLight(0xFFFFFF);
	        pointLight.position.x = center.x;
	        pointLight.position.y = center.y;
	        pointLight.position.z = center.z;
	        scene.add(pointLight);
		}
		// set scene
		//
		var scene;
		var camera
		var renderer;
		var init = function(rootnode)
		{
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			camera.position.z = 1;
			controls = new THREE.OrbitControls(camera);
			addLight(new THREE.Vector3(10, 50, 130), scene)
			scene.add(rootnode);
		}

		var lastComp = new THREE.Object3D();
		init(lastComp);

		// component draw section
		var m4;
		{% for comp in instrument.components %}
		addComponent();
			{% for drawcall in comp.drawcommands %}
				{% if drawcall.key == 'multiline' %}addMultiLine([{{drawcall.args_str}}]);{% endif %}
			{% endfor %}
		m4 = new THREE.Matrix4();
		m4.set({{comp.m4_str}});
		lastComp.applyMatrix(m4);
		{% endfor %}

		// TODO: neutron ray generation
		// create one ray object for each ray
		// add points as vertices to this Object3D (TODAY: ray events are in global coordinates, this should be changed into local, using "component" events (currently not present) )
		// create a Line as above

		// neutron ray data calls
		{% for ray in instrument.rays %} // TODO: add new Object3D here
			{% for event in ray.events %} // TODO: add the vertex using the first three coordinates of event.args_str
			{% endfor %}
		{% endfor %}

		// renderloop
		function render() {
			requestAnimationFrame( render );
			renderer.render( scene, camera );
		}
		render();
    </script>
</body>
</html>
