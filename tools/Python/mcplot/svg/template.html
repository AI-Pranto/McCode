<!DOCTYPE html>
<head>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="d3.v4.min.js"></script>
</head>
<body>
<script>
function plot_wrap(w, h, x, y, yerr, xlabel, ylabel, title) {
  var margin = 5;
  var wlab = w - 2*margin;
  var hlab = h - 2*margin;

  // axis labels

  var lblGroup = d3.select("body").append("svg")
    .attr("width", w)
    .attr("height", h)
    .append("g")
    .attr("transform", "translate(" + margin +"," + margin + ")");

  var titleGrp = lblGroup
    .append("text")
    .text(title)
    .attr("text-anchor", "middle");

  var xLabelGrp = lblGroup
    .append("text")
    .text(xlabel)
    .attr("dominant-baseline", "middle")
    .attr("text-anchor", "middle");

  var yLabelGrp = lblGroup
    .append("text")
    .attr("x", ylabx)
    .attr("y", ylaby)
    .text(ylabel)
    .attr("text-anchor", "middle");

  var dt = titleGrp.node().getBBox().height;
  var dl = yLabelGrp.node().getBBox().height; // height and width are confused here, due to the rotation
  var db = xLabelGrp.node().getBBox().height;

  var wplt = wlab - 3*dl;
  var hplt = hlab - (1.3*dt + 2*db);
  var xplt = 3*dl;
  var yplt = 1.3*dt;

  var titx = wlab/2;
  var tity = dt/2;
  var xlabx = wplt/2 + xplt;
  var xlaby = hlab - db/2;
  var ylabx = dl/2;
  var ylaby = yplt + hplt/2;

  // position labels based on what was drawn
  titleGrp.attr("transform", "translate(" + titx + "," + tity + ")");
  xLabelGrp.attr("transform", "translate(" + xlabx + "," + xlaby + ")");
  yLabelGrp.attr("transform", "rotate(-90," + ylabx + ',' + ylaby + ")  translate(" + ylabx + "," + ylaby + ")");

  var axisGroup = lblGroup
    .append("g")
    .attr("transform", "translate(" + xplt +"," + yplt + ")")
    .append("g");

  plot(wplt, hplt, x, y, yerr, axisGroup);
}

function plot(w, h, x, y, yerr, anchorElement) {
  // axis size fractions and orego placement fraction
  var xax_frac = 1;
  var yax_frac = 1;
  var x0_frac = 0;
  var y0_frac = 0;

  // axes lengths
  var wi = xax_frac*w;
  var hi = yax_frac*h;
  // orego
  var x0 = x0_frac*w;
  var y0 = h - y0_frac*h;
  // axes end coords
  var x1 = x0 + wi;
  var y1 = y0 - hi;

  var data = []
  for (var i=0; i < x.length; i++) {
    data.push({"x" : x[i], "y" : y[i]});
  }

  // zoom
  var zoom = d3.zoom()
    .on("zoom", zoomFunction);
  function zoomFunction() {
    // create new scale ojects based on event
    var new_xScale = d3.event.transform.rescaleX(xScale);
    var new_yScale = d3.event.transform.rescaleY(yScale);

    // update axes using the new scales
    xAxisGroup.call(xAxis.scale(new_xScale));
    yAxisGroup.call(yAxis.scale(new_yScale));

    // get a new data generator given the new scales
    var lf = getLineFunc(new_xScale, new_yScale);
    // clear & redraw based on the scaled data
    drawPoints(lf);
  };
  var view = anchorElement.append("rect")
    .attr("class", "zoom")
    .attr("width", w)
    .attr("height", h)
    .attr("style", "cursor: move; fill: none; pointer-events: all;")
    .call(zoom);

  // clip
  var clip = anchorElement.append("clipPath")
    .attr("id", "viewClip")
    .append("rect")
    .attr("width", w)
    .attr("height", h);

  // set up axes
  var xScale = d3.scaleLinear()
    .domain([d3.min(x), d3.max(x)])
    .range([x0, x1]);
  var xAxis = d3.axisBottom()
    .ticks(5)
    .scale(xScale);
  var xAxisGroup = anchorElement.append("g")
    .attr("transform", "translate(0," + y0 + ")")
    .call(xAxis);

  var yScale = d3.scaleLinear()
    .domain([d3.min(y), d3.max(y)])
    .range([y0, y1]);
  var yAxis = d3.axisLeft()
    .ticks(5)
    .scale(yScale);
  var yAxisGroup = anchorElement.append("g")
    .attr("transform", "translate(" + x0 + ", 0)")
    .call(yAxis);

  // enter data points
  var pointGroup = anchorElement.append("g")
  .attr("clip-path", "url(#viewClip)");

  // create initial scale object
  lf = getLineFunc(xScale, yScale)
  // draw data on initial zoom
  var points = drawPoints(lf);

  // data draw functions
  function getLineFunc(xScl, yScl) {
    return d3.line()
    .x(function(d) { return xScl(d.x); })
    .y(function(d) { return yScl(d.y); });
  }
  function drawPoints(lf) {
    pointGroup.selectAll("path").remove();
    pointGroup.append("path")
      .attr("d", lf(data))
      .attr("stroke", "black")
      .attr("stroke-width", "1px")
      .attr("fill", "none");
  }
}

  var x = @X_DATA_ARRAY@;
  var y = @Y_DATA_ARRAY@;
  var yerr = @YERR_DATA_ARRAY@;
  var w = @WIDTH@;
  var h = @HEIGHT@;
  var xlabel = "@XLABEL@";
  var ylabel = "@YLABEL@";
  var title = "@TITLE@";
  plot_wrap(w, h, x, y, yerr, xlabel, ylabel, title);
</script>
</body>
</html>
